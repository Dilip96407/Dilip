package de.westlb.mgb.converter;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;

import de.westlb.mgb.model.definition.JobStateDef;
import de.westlb.mgb.model.definition.MgbConfigurationDef;
import de.westlb.mgb.model.impl.AbstractManualState;
import de.westlb.mgb.model.impl.AutoStateHistEntryImpl;
import de.westlb.mgb.model.impl.AutomaticStateImpl;
import de.westlb.mgb.model.impl.BookImpl;
import de.westlb.mgb.model.impl.CounterpartyImpl;
import de.westlb.mgb.model.impl.DataLoadImpl;
import de.westlb.mgb.model.impl.JobImpl;
import de.westlb.mgb.model.impl.MandantImpl;
import de.westlb.mgb.model.impl.ManualStateHistEntryImpl;
import de.westlb.mgb.model.impl.ReclStateHistEntryImpl;
import de.westlb.mgb.model.impl.ReclamationStateImpl;
import de.westlb.mgb.model.impl.SourceSystemImpl;
import de.westlb.mgb.model.impl.StateImpl;
import de.westlb.mgb.model.impl.SummitAmendImpl;
import de.westlb.mgb.model.impl.TradeHistEntryImpl;
import de.westlb.mgb.model.impl.TradeImpl;
import de.westlb.mgb.model.impl.TraderImpl;
import de.westlb.mgb.model.impl.finder.JobSearchParams;
import de.westlb.mgb.model.impl.finder.MgbFinderImpl;
import de.westlb.mgb.model.impl.finder.TradeSearchParams;
import de.westlb.mgb.persistence.PersistenceException;
import de.westlb.mgb.persistence.Query;
import de.westlb.mgb.persistence.Session;
import de.westlb.mgb.persistence.StoreSingleton;
import de.westlb.mgb.persistence.Transaction;
import de.westlb.mgb.persistence.hibernate.SessionImpl;

/**
 * @author D055625
 *
 * Provides some base function for the mgb converters
 */
public abstract class MgbConverter {

	public static final String LOADER_NEW_STATUS = "NEW";
	public static String LOADER_ERROR_STATUS = "ERROR";
	public static String LOADER_WARNING_STATUS = "WARNING";
	public static String LOADER_OK_STATUS = "OK";

	static Logger logger = Logger.getLogger(MgbConverter.class);
	
	protected static final int BATCH_SIZE = SessionImpl.BATCH_SIZE;
	protected String importUser = "importuser";
	protected JobImpl job;
	protected SourceSystemImpl sourceSystemImpl;
	
	protected Session getSession() throws PersistenceException {
	    return StoreSingleton.getUniqueInstance().openBatchSession();
	}

    protected Session getSession(MandantImpl mandant, String importUser) throws PersistenceException {
        return StoreSingleton.getUniqueInstance().openBatchSession(mandant, importUser);
    }


	public MgbConverter(SourceSystemImpl sourceSystemImpl) {
		this.sourceSystemImpl = sourceSystemImpl;
	}

	/**
	 * this method clears the database-hibernate cache.
	 * it is necessary because the converters use an optimized batch-processing,
	 * which is faster. this is done by a different connection-pool.
	 * 
	 * unfortunately, the rest of the mgb-application can not use the batch-processing because it uses
	 * blob-objects in the database.
	 * 
	 * to avoid inconsitancy, the caches need to be cleared before and after every converter-call.  
	 * @see getSession() 
	 * @see de.westlb.mgb.converter.MgbConverter#processData()
	 */
    public long processData() {
        long startMillis = System.currentTimeMillis(); 
        long jobId = -1;
	    try {
	        StoreSingleton.getUniqueInstance().clearCache();
	        jobId = run();
	        StoreSingleton.getUniqueInstance().clearCache();
            logger.info("Processing job "+jobId+" finished. ("+(System.currentTimeMillis()-startMillis)+")");
       } catch (PersistenceException e) {
           logger.error("Error while clearing cache",e);
       }
       return jobId;
	}

	/**
	 * The main method to start the converter. The following methods are called in the following order:
	 * @see init()
	 * @see converterInit()
	 * @see convert()
	 * @see preProcess()
	 * @see process()
	 * @see postProcess()
	 * @see finish()
	 * 
	 * @return long the jobId generated by the init() method
	 */
    public long run() {
		long jobId = -1;
		try {
			if (job == null) {
				jobId = createJob();
			}
			start();
			converterInit();
			checkCompleteness();
			convert();
			logger.info("Processing job "+job.getLongId()+" ...");
			preProcess();
			process();
			postProcess();
			calculateBusinessStatistic();
			finish();
			return job.getLongId().longValue();
		} catch (Exception e) {
			setStatus(JobStateDef.JOB_ERROR_STATUS+": "+e.getMessage());
			logger.error("Error while Processing job "+jobId+": " + e.getMessage(),e);
		}
		return jobId;
	}

	/**
	 * Returns the class name without the package name of the class
	 * that holds the raw data from the source system. It is used when
	 * querying the database.
	 * 
	 * @return a query for the loader table selection
	 */
	protected String getLoaderTableSelectQuery() {
        return "select load from "+getLoaderTable().getName()+" load, "+BookImpl.class.getName() +" book where load.sourceSystem = '" + sourceSystemImpl.getCode() + "' and load.book = book.bookId";
	};

	/**
	 * Returns the class name without the package name of the class
	 * that holds the raw data from the source system. 
	 * 
	 * @return loader table 
	 */
	protected abstract Class<? extends DataLoadImpl> getLoaderTable();

	/**
	 * Returns a SourceSystemImpl to get the mandant information from the
	 * related persistent SourceSystemImpl. The mandant information is not
	 * used from the returned Object but from the persistent one from the database.
	 * 
	 * @return a source system to get the related mandant
	 */
	protected SourceSystemImpl getSourceSystem() {
		return sourceSystemImpl;
	};
	
	/**
	 * this function returns a subclass of TradeImpl.
	 * it is the class the converter will create.
	 * it can be used to narrow the hibernate return-object in hibernate queries.
	 * 
	 * @return the class of a subclass of TradeImpl
	 */
	protected Class<? extends TradeImpl> getTradeClass() {
		return TradeImpl.class;
	}

	/**
	 * The main routine to convert the source loader data to trade data of
	 * the MGB data model. 
	 * It creates a new instance of an apropriate subclass of TradeImpl.
	 * Any relations to other objects can be created here.
	 * 
	 * @param sess a Session can can be used for further database querying.
	 * @param loadData the Object with the source system loader data.
	 * @param job the job that hold the meta information of the imported data.
	 * @return a object that holds the converted trade infromation. 
	 * Will be a subclass from TradeImpl
	 */
	protected abstract TradeImpl convert(Session sess, DataLoadImpl loadData, JobImpl job) throws PersistenceException;

	/**
	 * should load any relevant data at the beginning of the conversion.
	 * @throws ConverterException
	 */
	protected abstract void converterInit() throws ConverterException;

	/**
	 * Method preProcess.
	 * @throws ConverterException
	 */
	protected abstract void preProcess() throws ConverterException;

	/**
	 * Method process.
	 * @throws ConverterException
	 */
	protected abstract void process() throws ConverterException;

	/**
	 * checks if all trades from the loader table have been processed as
	 * expected. especially relevant of Delegation converters that share one#
	 * loader table.
	 * throws an exception if the check fails.
	 * 
	 * @throws ConverterException
	 */
	protected abstract void checkCompleteness() throws ConverterException;

	/**
	 * Method postProcess.
	 * @throws ConverterException
	 */
	private void postProcess() throws ConverterException {
		try {
			logger.info("PostProcessing job "+job.getLongId()+"...");
			saveNewTrader();
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			throw new ConverterException("Error while PostProcessing job "+job.getLongId()+": " + e.getMessage(), e);
		}
		logger.info("PostProcessing job "+job.getLongId()+" finished.");
	}

	/**
	 * Creates the new JobImpl object.
	 * 
	 * @return long the new jobId
	 * @throws ConverterException
	 */
    public long createJob() throws ConverterException {
		logger.info("Receiving configuration...");
		long jobId = -1;
		Session sess = null;
		try {
			sess = getSession();

			logger.info("Receiving configuration finished.");
			logger.info("Initialising...");
			SourceSystemImpl sourceSystem = (SourceSystemImpl) sess.select(SourceSystemImpl.class, getSourceSystem().getCode());
			sess.close();

			sess = getSession(sourceSystem.getMandant(), importUser);
			Transaction t = sess.beginTransaction();

			job = (JobImpl) sess.create(JobImpl.class);
			job.setSourceSystem(sourceSystem);
			job.setStatus(JobStateDef.JOB_RUNNING_STATUS);
			job.setArchived(false);
			sess.save(job);

			String hql = String.format("delete from "+getLoaderTable().getName()+" where sourceSystem='"+sourceSystemImpl.getCode()+"'");
		    Query query = sess.createQuery(hql);
		    query.executeUpdate();

			t.commit();
			if (job.getLongId() != null) {
				jobId = job.getLongId().longValue();
			}

		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			throw new ConverterException("Error while creating a job: " + e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }

			} catch (PersistenceException he) {
			}
		}
		logger.info("Created job "+jobId+" ("+getSourceSystem().getName()+")");
		logger.info("Initialising finished.");
		return jobId;
	}

    /**
     * Iterates over the loader table, and
     * converts Method converts a DataLoadImpl to a TradeImpl.
     * The success of the conversion is saved to the loader table.
     * 
     * @see convert(Session, DataLoadImpl, JobImpl)
     * @throws ConverterException
     */
	protected void convert() throws ConverterException {
        Session sess = null;
        long start = System.currentTimeMillis();
        try {
            logger.info("Converting job "+job.getLongId()+"...");
            int convertErrors = 0;
            sess = getSession(job.getMandant(), importUser);

            logger.debug("query:" + getLoaderTableSelectQuery());

            Query query = sess.createQuery(getLoaderTableSelectQuery());

            logger.debug("HQL: "+query.getQueryString());
            Collection<DataLoadImpl> col = query.list();
            int total = col.size();
            int i = 0;
            int count = 0;
            
            HashMap<Serializable, String> errorList = new HashMap<Serializable, String>(); 
            Iterator<DataLoadImpl> it = col.iterator();
            Transaction t = sess.beginTransaction();
            while (it.hasNext()) {
                i++;
                DataLoadImpl loadData = it.next();
                logger.debug("Converting loaderData record: " + loadData.getId() + " (" + i + " of " + total + ")");

                try {
                    @SuppressWarnings("unused")
                    TradeImpl trade = convert(sess, loadData, job);
                } catch (PersistenceException se) {
                    String message = se.getMessage();
                    if (message != null) {
                        errorList.put(loadData.getId(), message.substring(0,Math.min(message.length(),DataLoadImpl.LOAD_MESSAGE_MAX_LENGTH)));
                        logger.error(message, se);
                    }
                    convertErrors++;
                }
                if ( ++count % BATCH_SIZE == 0 ) {
                    //flush a batch of updates and release memory:
                    sess.flush();
                    sess.clear();
                }
            }
            t.commit();

            count = 0;
            Transaction lt = sess.beginTransaction();
            for (Iterator<DataLoadImpl> iterator = col.iterator(); iterator.hasNext();) {
                DataLoadImpl loadData = iterator.next();
                if (errorList.containsKey(loadData.getId())) {
                    loadData.setLoadMessage(errorList.get(loadData.getId()));
                    loadData.setLoadStatus(LOADER_ERROR_STATUS);
                } else {
                    loadData.setLoadStatus(LOADER_OK_STATUS);
                }
                sess.update(loadData);
                if ( ++count % BATCH_SIZE == 0 ) {
                    //  flush a batch of updates and release memory:
                    sess.flush();
                    sess.clear();
                }
            }	            
            lt.commit();
            
            Transaction jt = sess.beginTransaction();
            job.setNumberOfConvertErrors(convertErrors);
            sess.update(job);
            jt.commit();

        } catch (Exception e) {
            logger.error("Error while converting job "+job.getLongId()+": ", e);
            throw new ConverterException("Error while converting: " + e.getMessage(), e);
        } finally {
            try {
                if (sess != null) {
                    sess.close();
                }                    
            } catch (PersistenceException pe) {
            }
        }
        logger.info("Converting job "+job.getLongId()+" finished.");
        logger.info("Took " + (System.currentTimeMillis() - start) + " millis.");
    }


	/**
	 * save the statistical finish info to the job object
	 * and remove former empty jobs from the same business day
	 */
	private void finish() {
		Session sess = null;
		try {
			sess = getSession(job.getMandant(), importUser);
			Transaction t = sess.beginTransaction();
			job.setStopConvertTime(new GregorianCalendar());
			if (job.getNumberOfConvertErrors() == 0) {
				job.setStatus(JobStateDef.JOB_OK_STATUS);
			} else {
				job.setStatus(JobStateDef.JOB_ERROR_STATUS);
			}
			sess.update(job);

			if (job.getStopBusinessTime() != null)
			{
				MgbFinderImpl finder = new MgbFinderImpl(sess);
	            JobSearchParams params = new JobSearchParams(job.getMandant(), job.getSourceSystem(), job.getStopBusinessTime(), new String[]{JobStateDef.JOB_OK_STATUS, JobStateDef.JOB_CLOSED_STATUS, JobStateDef.JOB_SPK_CLOSED_STATUS}, false); 
	            Collection<JobImpl> oldJobs = finder.findJobs(params);
	            
	            SourceSystemImpl sourceSystem = (SourceSystemImpl)
	                    sess.select(SourceSystemImpl.class,getSourceSystem().getCode());
	            int expectedJobs = sourceSystem.getExpectedJobs();
	            
	            /* Remove only jobs that exceed the 'expected' count for the
	             * business day even if others are empty too, to not confuse Nagios */
	            for (JobImpl oldJob : oldJobs) {
	                if(expectedJobs-->0) continue;
	                if (oldJob.getNumberOfTotalRecords() == 0 && !oldJob.getLongId().equals(job.getLongId())) {
	                    /*
	                     * Note: this codepath seems to fail sometimes, which is
	                     * expected to be no problem. This seems to happen whenever
	                     * the trade table contains entries that point to a job that
	                     * indicates 0 total records. These should be (partially)
	                     * failed jobs, e. g. in a test on 2013-07-26, an initially
	                     * missing book could not be created because a parallel job
	                     * had already done so; the job created 3 load errors, but
	                     * still wired itself to the three trades which were saved
	                     * successfully into the DB.
	                     * 
	                     * -- RS 2013-07-29
	                     */
	                    sess.delete(oldJob);
	                    logger.info("Deleted empty old job "+oldJob.getLongId()+" for "+sourceSystem+".");
	                }            
	            }
			}
			t.commit();
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException pe) {
			}
		}
	}

	/**
	 * save the statistical start info to the job object
	 */
	private void start() {
		Session sess = null;
		try {
			sess = getSession(job.getMandant(), importUser);
			Transaction t = sess.beginTransaction();
			job.setStartConvertTime(new GregorianCalendar());
			job.setStatus(JobStateDef.JOB_RUNNING_STATUS);
			sess.update(job);
			t.commit();
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException pe) {
			}
		}
	}

	/**
	 * saves the statistic of the loader process (SQLLDR.EXE) to the loader table.
	 * 
	 * @see de.westlb.mgb.converter.MgbConverter#setLoaderStatistic(java.util.Calendar, java.util.Calendar, int)
	 */
    public void setLoaderStatistic(Calendar startLoadTime, Calendar stopLoadTime, int numberOfLoadErrors) {
		Session sess = null;
		try {
			if (job == null) {
				@SuppressWarnings("unused")
                long jobId = createJob();
			}
			sess = getSession(job.getMandant(), importUser);
			Transaction t = sess.beginTransaction();
			job.setStartLoadTime(startLoadTime);
			job.setStopLoadTime(stopLoadTime);
			job.setNumberOfLoadErrors(numberOfLoadErrors);
			sess.update(job);
			t.commit();
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException pe) {
			}
		}
	}


	/**
	 * saves the data of the last line of the data file, that contains
	 * the business statistic to the loader table.
	 * 
	 */
    public void setBusinessStatistic(int numberOfTotalRecords, Calendar cob, Calendar startBusinessTime, Calendar stopBusinessTime, Calendar systemTime) {
		Session sess = null;
		try {
			if (job == null) {
				@SuppressWarnings("unused")
                long jobId = createJob();
			}
			sess = getSession(job.getMandant(), importUser);
			Transaction t = sess.beginTransaction();
			job.setNumberOfTotalRecords(numberOfTotalRecords);
			job.setCob(cob);
			job.setStartBusinessTime(startBusinessTime);
			job.setStopBusinessTime(stopBusinessTime);
			job.setSystemTime(systemTime);
			sess.update(job);
			t.commit();
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException pe) {
			}
		}
	}

    /**
     * Setting the current dates of the jobs, by analyzing the trades data of the specified job-ids.
     * Empty business-dates and business-dates in the future are replaced. 
     * 
     * @param jobIds if null, only the current job is taken into account.
     */
    public void calculateBusinessStatistic() {
        Session sess = null;
        try {
            if (job == null) {
                @SuppressWarnings("unused")
                long jobId = createJob();
            }
            Calendar extractDate = Calendar.getInstance();
            if (job.getSystemTime() != null) {
                extractDate = job.getSystemTime();
            }
            if (job.getStartBusinessTime() == null 
                    || job.getStopBusinessTime() == null
                    || extractDate.before(job.getStartBusinessTime())
                    || extractDate.before(job.getStopBusinessTime()) ) {
                sess = getSession(job.getMandant(), importUser);
                Transaction t = sess.beginTransaction();
                String jobIdsString = ""+job.getLongId();
                Query query = sess.createQuery("select min(trade.amendedDate), max(trade.amendedDate), max(trade.tradeDate) "+
                        "from TradeImpl trade "+
                        "where trade.tradeDate < :extractDate "+
                        "and trade.amendedDate < :extractDate "+
                        "and trade.job.longId in ("+ jobIdsString +")");
                query.setParameter("extractDate", extractDate);
                Collection<Object[]>col = query.list();
                Iterator<Object[]> it = col.iterator();
                if (it.hasNext()) {
                    Object[] element = it.next();
                    if (element[0] != null && element[1] != null && element[2] != null) {
                        job.setStartBusinessTime((Calendar)element[0]);
                        if (((Calendar)element[1]).after(element[2])) {
                            job.setStopBusinessTime((Calendar)element[1]);
                        } else {
                            job.setStopBusinessTime((Calendar)element[2]);
                        }
                        logger.debug("Setting calculated business date for job "+ job.getLongId() +" to "+job.getStartBusinessTime().getTime()+" and "+job.getStopBusinessTime().getTime());
                        sess.update(job);
                    }
                }
                t.commit();
            }
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            try {
                if (sess != null) {
                    sess.close();
                }
            } catch (PersistenceException pe) {
            }
        }
    }


    public void setStatus(String status) {
		Session sess = null;
		try {
			if (job == null) {
				@SuppressWarnings("unused")
                long jobId = createJob();
			}
			sess = getSession(job.getMandant(), importUser);
			Transaction t = sess.beginTransaction();
			if (status != null && status.length() > JobImpl.JOB_STATUS_MAX_LENGTH) {
				job.setStatus(status.substring(0, JobImpl.JOB_STATUS_MAX_LENGTH-1));
			} else {
				job.setStatus(status);
			}
			sess.update(job);
			t.commit();
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException pe) {
			}
		}
	}

    public void setArchiveFileName(String archiveFileName) {
        Session sess = null;
        try {
            if (job == null) {
                @SuppressWarnings("unused")
                long jobId = createJob();
            }
            sess = getSession(job.getMandant(), importUser);
            Transaction t = sess.beginTransaction();
            if (archiveFileName != null && archiveFileName.length() > JobImpl.JOB_ARCHIVE_FILE_NAME_MAX_LENGTH) {
                job.setArchiveFile(archiveFileName.substring(0, JobImpl.JOB_ARCHIVE_FILE_NAME_MAX_LENGTH - 1));
            } else {
                job.setArchiveFile(archiveFileName);
            }
            sess.update(job);
            t.commit();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            try {
                if (sess != null) {
                    sess.close();
                }
            } catch (PersistenceException pe) {
            }
        }
    }

    public void setImportFileName(String importFileName) {
        Session sess = null;
        try {
            if (job == null) {
                @SuppressWarnings("unused")
                long jobId = createJob();
            }
            sess = getSession(job.getMandant(), importUser);
            Transaction t = sess.beginTransaction();
            if (importFileName != null && importFileName.length() > JobImpl.JOB_IMPORT_FILE_NAME_MAX_LENGTH) {
                job.setImportFile(importFileName.substring(0, JobImpl.JOB_IMPORT_FILE_NAME_MAX_LENGTH - 1));
            } else {
                job.setImportFile(importFileName);
            }
            sess.update(job);
            t.commit();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            try {
                if (sess != null) {
                    sess.close();
                }
            } catch (PersistenceException pe) {
            }
        }
    }

	protected void saveNewBooks() throws PersistenceException {
		Session sess = null;
		try {
			sess = getSession(job.getMandant(), importUser);
			MgbFinderImpl finder = new MgbFinderImpl(sess);
			TradeSearchParams param = new TradeSearchParams();
			param.setJobs(new JobImpl[] { job });
			Collection<String> col1 = finder.findNewSourceSystemBookIds(param);
			Iterator<String> i1 = col1.iterator();
			Transaction t1 = sess.beginTransaction();
			int count=0;
			while (i1.hasNext()) {
				String bookId = i1.next();
				BookImpl book = new BookImpl(bookId);
				sess.save(book);
				logger.debug("Saving new book '" + book.getBookId() + "'");
			    if ( ++count % BATCH_SIZE == 0 ) {
			        //flush a batch of updates and release memory:
			        sess.flush();
			        sess.clear();
			    }
			}
			t1.commit();

			Collection<Object[]> coll = finder.findUnlinkedTradeAndBook(param);
			Iterator<Object[]> i = coll.iterator();
			Transaction t = sess.beginTransaction();
			while (i.hasNext()) {
				Object[] o = i.next();
				TradeImpl trade = (TradeImpl) o[0];
				BookImpl book = (BookImpl) o[1];
				trade.setBook(book);
				logger.debug("Saving book '" + book.getBookId() + "' for trade " + trade.getTradeId());
			}
 			t.commit();
		} catch (PersistenceException e) {
			logger.error(e.getMessage(), e);
			throw e;
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException he) {
			}
		}
	}
	
	/**
	 * Sets the reference from Trades
	 * to counterparties.
	 * @throws PersistenceException
	 */
	protected void saveCounterparties() throws PersistenceException {
		Session sess = null;
		try {
			Transaction t;
			sess = getSession(job.getMandant(), importUser);

			t = sess.beginTransaction();
			MgbFinderImpl finder = new MgbFinderImpl(sess);
			TradeSearchParams param = new TradeSearchParams();
			param.setJobs(new JobImpl[] { job });
			Collection<Object[]> coll = finder.findUnlinkedTradeAndCounterparty(param);
			Iterator<Object[]> i = coll.iterator();
			while (i.hasNext()) {
				Object[] o = i.next();
				TradeImpl trade = (TradeImpl) o[0];
				CounterpartyImpl counterpary = (CounterpartyImpl) o[1];
				trade.setCounterparty(counterpary);
				logger.debug("Saving counterparty '" + counterpary.getCounterpartyId() + "' for trade " + trade.getTradeId());
			}
			t.commit();

		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			throw new PersistenceException(e.getMessage(), e);
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException he) {
			}
		}
		
	}

	protected void saveNewTrader() throws PersistenceException {
		Session sess = null;
		try {
			sess = getSession(job.getMandant(), importUser);
			MgbFinderImpl finder = new MgbFinderImpl(sess);
			TradeSearchParams param = new TradeSearchParams();
			param.setJobs(new JobImpl[] { job });
			Collection<Object[]> col1 = finder.findNewSourceSystemTrader(param);
            int count=0;
			Iterator<Object[]> i1 = col1.iterator();
			Transaction t1 = sess.beginTransaction();
			while (i1.hasNext()) {
				Object[] o = i1.next();
                TraderImpl trader = (TraderImpl)sess.create(TraderImpl.class);
				trader.setSourceSystem((SourceSystemImpl) o[0]);
				trader.setTraderCode((String) o[1]);
				logger.debug("Saving new trader '" + trader.getTraderCode() + "'");
                if ( ++count % BATCH_SIZE == 0 ) {
                    //flush a batch of updates and release memory:
                    sess.flush();
                    sess.clear();
                }
			}
			t1.commit();

			Collection<Object[]> coll = finder.findUnlinkedTradeAndTrader(param);
			Iterator<Object[]> i = coll.iterator();
			Transaction t = sess.beginTransaction();
			while (i.hasNext()) {
				Object[] o = i.next();
				TradeImpl trade = (TradeImpl) o[0];
				TraderImpl trader = (TraderImpl) o[1];
				trade.setTrader(trader);
				logger.debug("Saving trader '" + trader.getTraderCode() + "' for trade " + trade.getId());
			}
			t.commit();
		} catch (PersistenceException e) {
			logger.error(e.getMessage(), e);
			throw e;
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException he) {
			}
		}

	}

	protected void setCurrentState(Session sess, TradeImpl trade, StateImpl state, String comment) throws PersistenceException {
		TradeHistEntryImpl histEntry = null;
		if (state instanceof AutomaticStateImpl) {
			histEntry = new AutoStateHistEntryImpl();
			((AutoStateHistEntryImpl) histEntry).setAutomaticState((AutomaticStateImpl) state);
		} else if (state instanceof AbstractManualState) {
			histEntry = new ManualStateHistEntryImpl();
			((ManualStateHistEntryImpl) histEntry).setManualState((AbstractManualState) state);
		} else if (state instanceof ReclamationStateImpl) {
			histEntry = new ReclStateHistEntryImpl();
			((ReclStateHistEntryImpl) histEntry).setReclamationState((ReclamationStateImpl) state);
		}
		if (histEntry != null) {
    		histEntry.setStateTime(new GregorianCalendar());
    		histEntry.setTrade(trade);
    		if (comment != null) {
    			histEntry.setComment(comment.substring(0, Math.min(TradeHistEntryImpl.COMMENT_MAX_LENGTH, comment.length())));
    		}
    		sess.save(histEntry);
    		trade.setCurrentStateHistEntry(histEntry);
		}
	}

    protected void setTradeGroups() throws PersistenceException {
		Session sess = null;
		try {
			sess = getSession(job.getMandant(), importUser);
			Transaction t = sess.beginTransaction();

			Query query =
				sess.createQuery(
					"from "+getTradeClass().getName()+" trade where trade.job = :job and trade.tradeId in ("
						+ "select t1.tradeId "
						+ "from "+getTradeClass().getName()+" t1, "+getTradeClass().getName()+" t2 "
						+ "where "
						+ "t1.tradeId <> t2.tradeId "
						+ "and "
						+ "t1.tradeGroupId = t2.tradeGroupId "
						+ "and "
						+ "t1.tradeGroupId <> '0' "
						+ "and "
						+ "t1.job = :job "
						+ "and "
						+ "t2.job = :job "
						+ ")");
            logger.debug("HQL: "+query.getQueryString());
			query.setParameter("job", job);
            int count=0;
            Iterator<TradeImpl> it = query.iterate();
			while (it.hasNext()) {
				TradeImpl trade = (TradeImpl) sess.select(TradeImpl.class,it.next().getId());
				trade.setIsTradeGroup(true);
				logger.debug("Setting " + trade.getId() + " to isTradeGroup.");
                if ( ++count % BATCH_SIZE == 0 ) {
                    //flush a batch of updates and release memory:
                    sess.flush();
                    sess.clear();
                }
			}
			t.commit();

		} catch (PersistenceException e) {
			logger.error(e.getMessage(), e);
			throw e;
		} finally {
			try {
                if (sess != null) {
                    sess.close();
                }
			} catch (PersistenceException he) {
			}
		}
	}

    /**
     * Sets the {@link TradeImpl#isTradeGroup()} flag to indicate whether an
     * amendment (in terms of {@link SummitAmendImpl}) where this trade was
     * assigned to the "NEW" version exists.
     * <p>
     * If yes, this does not automatically mean that a suitable "OLD" version
     * exists in the database. It probably should be the case but it isn't,
     * which I suppose means the old versions were initially missing from the
     * respective mcc_trade report files OR the amendment referred to a
     * change on the same day. &ndash; RS 2015-11-06
     * </p>
     */
    protected void setTradeAmendGroups() throws PersistenceException {
        Session sess = null;
        try {
            sess = getSession(job.getMandant(), importUser);
            Transaction t = sess.beginTransaction();

            Query query =
                sess.createQuery(
                    "select distinct newTrade from "+getTradeClass().getName()+" newTrade, "+SummitAmendImpl.class.getName()+" amend "+
                    "where newTrade.job = :job " +
                    "and newTrade.tradeId = amend.tradeIdNew "
                     );
            logger.debug("HQL: "+query.getQueryString());
            query.setParameter("job", job);
            int count=0;
            Iterator<TradeImpl> it = query.iterate();
            while (it.hasNext()) {
                TradeImpl trade = (TradeImpl) sess.select(TradeImpl.class,it.next().getId());
                trade.setIsTradeGroup(true);
                logger.debug("Setting " + trade.getId() + " to isTradeGroup(amended).");
                if ( ++count % BATCH_SIZE == 0 ) {
                    //flush a batch of updates and release memory:
                    sess.flush();
                    sess.clear();
                }
            }
            t.commit();

        } catch (PersistenceException e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            try {
                if (sess != null) {
                    sess.close();
                }
            } catch (PersistenceException he) {
            }
        }
    }
    
	protected ArrayList<String> arrayFromMgbConfiguration(MgbFinderImpl finder, String mgbConfigurationKey) throws PersistenceException {
		String mgbConfigurationValue = finder.findMgbConfigurationValue(job.getMandant(), mgbConfigurationKey);
		if (mgbConfigurationValue != null) {
			return new ArrayList<String>(Arrays.asList(StringUtils.split(mgbConfigurationValue, MgbConfigurationDef.MGB_CONFIGURATION_LIST_DELIMITER)));
		}
        return new ArrayList<String>();
	}

	public long getJobId(){
	    return (job == null || job.getLongId() == null) ? -1 : job.getLongId().longValue();
	}
}